#include<systemc>#include<iostream>using namespacesc_core ;SC_MODULE( Proc ){public:SC_HAS_PROCESS( Proc ) ;Proc (sc_module_name ) ;protected:voidprint (const char∗s t r ) ;sc_event  clk ,  a ,  b ;voidclk_thread ( ) ;voidab_thread ( ) ;voidstatic_method ( ) ;voiddynamic_method ( ) ;intab_int ;};Proc : : Proc (sc_module_name name)  :  sc_module (name){SC_THREAD( clk_thread ) ;SC_THREAD( ab_thread ) ;SC_METHOD( static_method ) ;s e n s i t i v e << a << b ;SC_METHOD(dynamic_method ) ;s e n s i t i v e << a << b ;ab_int = 0;}voidProc : : print (const char∗s t r ){std : : cout <<"@␣" <<sc_time_stamp () << "␣" <<s t r <<std : : endl ;}voidProc : : clk_thread (){while(1){wait (5 , SC_NS) ;clk . notify ( ) ;}}voidProc : : ab_thread (){while(1){wait (5 , SC_NS) ;a . notify ( ) ;wait (5 , SC_NS) ;b . notify ( ) ;}}voidProc : : static_method (){print ( " Static ␣method" ) ;}voidProc : : dynamic_method (){sc_time d(3 , SC_NS) ;switch( ab_int ){case0:print ( "Dynamic␣method␣AB" ) ;next_trigger ( a ) ;break;case1:print ( "Dynamic␣method␣A" ) ;next_trigger (b ) ;break;case2:print ( "Dynamic␣method␣B" ) ;next_trigger (d ) ;break;case3:print ( "Dynamic␣method␣−␣ timeout " ) ;next_trigger (d ,  a  |  b ) ;break;case4:print ( "Dynamic␣method␣−␣ timeout ␣ or ␣AB" ) ;next_trigger ( ) ;break;default:a s s e r t (false) ;}ab_int = ( ab_int + 1) % 5;}intsc_main (intargc ,char∗argv [ ] ){Proc  uut ( "UUT" ) ;sc_start (100 , SC_NS) ;return0;}
